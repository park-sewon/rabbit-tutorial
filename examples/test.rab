(* security primitives *)
function pk:1
function enc:2
function sign:2
function dec:2
function pair:2
function verify:3

function fst:1
function snd:1
function test:0
function true:0

(* syscall on channels *)

(** asynchronous channels *)
syscall send(channel c, v) 
  : [] -> [c:store(v)]
syscall recv(channel c) return v 
  : [c:store(v)] -> [] 

(** synchronous rpc channel *)

syscall connect_rpc (channel c) return x
  : [] -> [c:ask()] 
 => [c:accept(), &Fr(x)] -> [c:connect(), chid(c, x)]

syscall invoke_rpc (channel c, f, args) return x
  	: [c:connect()] -> [c:invoke(f, args), c:connect()]
	=>[c:returns(x)] -> []

syscall close_rpc (i)
	: [c:connect(), chid(c, i)] -> [c:close()]

syscall accept_rpc (channel c)
	: [c:ask()] -> [c:accept()] 
	=>
	{!{[c:invoke(f, args)] -> [run(f, args)] => [returned(f, x)] -> [c:returns(x)]}
	||  [c:close()] -> []}


	(* => ! ([c:invoke(f, args)] -> [connect(c)] || [c:close()] -> []) *)


(* filesys *)
syscall fopen (path p) return x 
  : [&Fr(x)] -> [p.fd(x)]  

syscall fread (y) return x 
  : [p.File(x), p.fd(y)] -> [p.File(x), p.fd(y)] 

syscall fclose (y)
  : [p.File(x), p.fd(y)] -> [p.File(x)] 


(* attacker model *)
attack tampar_ch (channel c) : [c:store(v), In(w)] -> [c:store(w)]
attack eaves_ch  (channel c) : [c:store(v)]  	   -> [c:store(v), Out(v)]
attack drop_ch   (channel c) : [c:store(v)] 	   -> []


(***********)
(** declare types with their classes *)
type read_only 	  : filesys

type server_t 	  : process
type client_t 	  : process
type client_ta_t  : process

type sync_t 	  : channel
type async_t 	  : channel

(***********)
allow client_t async_t [send]
allow server_t async_t [recv]

allow client_t sync_t 	   [connect_rpc, invoke_rpc, close_rpc]
allow client_ta_t sync_t  [accept_rpc]

allow server_t read_only [fopen, fread, fclose]  
allow client_t read_only [fopen, fread, fclose]  
allow client_ta_t read_only [fopen, fread, fclose]  

(***********)
(*
allow attack sync_t [tampar]
allow attack async_t [tampar]
*)

(***********)
const fresh priv_k
const fresh sym_k
const fresh init_data


(***********)
channel udp : async_t
channel rpc : sync_t

(***********)
filesys client_fs = 
  [ 
    {path: "/dev/camera", data: init_data, type: read_only}
  ]

filesys server_fs = 
  [ 
    {path: "/secret/pub", data: pk(priv_k), type: read_only}
  ]

filesys client_ta_fs = 
  [ 
    {path: "/secret/priv", data: enc(priv_k, sym_k), type: read_only}
  ]

(***********)
process client(ch_rpc) with client_t 
{  
	let a = "a";
	let b = "b";

	main 
  	{
		
			let conn = connect_rpc(ch_rpc) @ B();
      	
  		let sig = invoke_rpc(ch_rpc, "sewon", (a, b)) @ Got(sig);
 	    	
	  	let _ = close_rpc(conn);
  	}
}

process client_ta(ch_rpc) with client_ta_t 
{
	let c = "c";

  	function sewon(a, b) 
  	{
  		let d = pair(a, b); 
  		let e = pair (c, d);
	    return e;
	}
  
  	main 
  	{
    	let conn = accept_rpc(ch_rpc);
  	}
}

(***********)
system 
	client(rpc) with client_fs
||	client_ta(rpc) with client_ta_fs
requires  [
      lemma Reachability2 :
    exists-trace "Ex #j  . B() @ #j"  ;
  lemma Reachability3 :
    exists-trace "Ex x #j  . Got(x) @ #j" 
    ]


    