theory camimage 

begin

 functions: myone/0, myzero/0, myplus/2
equations: myplus(x, y)=myplus(y, x), myplus(x, myzero())=x
rule Send_udp : [Send_udp(proc, c, v)]-->[Send_udp__return(proc, ''), Store(c, v)] 
rule Recv_udp : [Recv_udp(proc, c), Store(c, v)]-->[Recv_udp__return(proc, v)] 
rule Connect_tcp : [Connect_tcp(proc, c), Accept(proc, c)]-->[Connect_tcp__0(proc, c), Connect(proc, c)] 
rule Connect_tcp__0 : [Connect_tcp__0(proc, c)]-->[Connect_tcp__return(proc, ''), Ask(proc, c)] 
rule Accept_tcp : [Accept_tcp(proc, c), Connect(proc, c)]-->[Accept_tcp__0(proc, c), Connect(proc, c)] 
rule Accept_tcp__0 : [Accept_tcp__0(proc, c), Ask(proc, c)]-->[Accept_tcp__return(proc, ''), Accept(proc, c)] 
rule Send_tcp : [Send_tcp(proc, c, v), Receipt(proc, c)]-->[Send_tcp__0(proc, c, v)] 
rule Send_tcp__0 : [Send_tcp__0(proc, c, v), Connect(proc, c)]-->[Send_tcp__return(proc, ''), Dataa(proc, c, v), Connect(proc, c)] 
rule Recv_tcp : [Recv_tcp(proc, c), Dataa(proc, c, v), Connect(proc, c)]-->[Recv_tcp__return(proc, v), Receipt(proc, c), Connect(proc, c)] 
rule Client0__init : []--[Client0_init()]->[Client0__init()] 
rule Client0__init__0 : [Client0__init()]-->[Client0__init__0(myplus(myone(), myone()))] 
rule Client0__main : [Client0__init__0(mytwo)]-->[Client0__main(mytwo)] 
rule Client0__main__in : [Client0__main(mytwo)]-->[Client0__main__wait(mytwo), Send_udp('Client0', 'decent_channel', mytwo)] 
rule Client0__main__out : [Client0__main__wait(mytwo), Send_udp__return('Client0', rabbit)]--[Querying()]->[Client0__main__0('', mytwo)] 
rule Client0__main__0__in : [Client0__main__0('', mytwo)]-->[Client0__main__0__wait('', mytwo), Recv_udp('Client0', 'decent_channel')] 
rule Client0__main__0__out : [Client0__main__0__wait('', mytwo), Recv_udp__return('Client0', four)]--[Computed(four)]->[Client0__main__1(four, '', mytwo)] 
rule Server1__init : []--[Server1_init()]->[Server1__init()] 
rule Server1__double : [Server1__double(x2, x1)]--[Doubling(x1)]->[Server1__double__0(myplus(x1, x2), x2, x1)] 
rule Server1__double__return : [Server1__double__0(y, x2, x1)]-->[Server1__double__return(y)] 
rule Server1__main : [Server1__init()]-->[Server1__main()] 
rule Server1__main__in : [Server1__main()]-->[Server1__main__wait(), Recv_udp('Server1', 'decent_channel')] 
rule Server1__main__out : [Server1__main__wait(), Recv_udp__return('Server1', x)]--[Receiving(x)]->[Server1__main__0(x)] 
rule Server1__main__0__in : [Server1__main__0(x)]-->[Server1__main__0__wait(x), Server1__double(x, x)] 
rule Server1__main__0__out : [Server1__main__0__wait(x), Server1__double__return(double_x)]-->[Server1__main__1(double_x, x)] 
rule Server1__main__1__in : [Server1__main__1(double_x, x)]-->[Server1__main__1__wait(double_x, x), Send_udp('Server1', 'decent_channel', double_x)] 
rule Server1__main__1__out : [Server1__main__1__wait(double_x, x), Send_udp__return('Server1', rabbit)]-->[Server1__main__2('', double_x, x)] 

restriction Client0_init : 
  " All x #i #j . Client0_init() @ #i & Client0_init() @ #j ==> #i = #j "

restriction Server1_init : 
  " All x #i #j . Server1_init() @ #i & Server1_init() @ #j ==> #i = #j "

lemma Finish :
  exists-trace
  "Ex k #j  . Computed(k) @ #j"
