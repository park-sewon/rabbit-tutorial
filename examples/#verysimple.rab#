(* Very Simple RAB file for computing 4 *)


(***********)
(** declare external constants and functions as a equational theory *)
(* function : arity where arity = 0 defines constant *)
external function add:2
external function O:0
external constant ichi

equation add(x, O) = x
equation add(O, x) = x


(***********)
(* declare system calls *)
(* [A] -> [B] waits for A instead of abort 
 * [A] -> [B] => [C] -> [D] runs [A] -> [B] then  [C] -> [D]
 * preconditions are consumed; e.g., [A] -> [] when succeeds remove [A]
 * All facts, unless scoped by a channel variable, are local to the 
   process that calls the system call. *)
external syscall send_udp(channel c, v) : [] -> [c:store(v)]
external syscall recv_udp(channel c) return v : [c:store(v)] -> [] 

external syscall connect_tcp(channel c)
  : [] -> [ask(c)] => [accept(c)] -> [connect(c)]
external syscall accept_tcp(channel c)
  : [ask(c)] -> [accept(c)] => [c:connect()] -> [c:connect()]
external syscall send_tcp(channel c, v)
  : [connect(c)] -> [connect(c), dataa(c, v)] => [receipt(c)] -> []
external syscall recv_tcp(channel c) return v
  : [connect(c), dataa(c, v)] -> [connect(c), receipt(c)] 


(***********)
(** declare types with their classes *)
type filesys_t 	: filesys
type server_t 	: process
type client_t 	: process
type channel_t 	: channel


(***********)
(** declare allowed accesses and attacks. 
    Attacks under the current extension is not supported yet.. *)
allow client_t channel_t [send_udp, recv_udp]
allow server_t channel_t [send_udp, recv_udp]
(* attack server_t [tamper] *)
(* attack channel_t [eavesdrop,tamper] *)


(***********)
(** define channels and file systems *)
channel decent_channel : channel_t
filesys boring_filesys = [{path: "some/path", data: O, type: filesys_t}]


(***********)
(** define process templates *)
process client(c) with client_t {
	let mytwo = add(ichi, ichi) ; 
	let rabbit = ichi;
	main {
		let _ = send_udp(c, mytwo) @ Querying();
		let four = recv_udp(c) @ Computed(four);
	}
}

process server(c) with server_t {
	function double (x1, x2){
		let y = add (x1, x2) @ Doubling(x1);
		return y;
	}
	main {
		let x = recv_udp(c) @ Receiving(x); 
		let double_x = double(x, x); 
		let _ = send_udp(c, double_x);
	}
}


(***********)
(** realize a system *)
system client(decent_channel) with boring_filesys
||     server(decent_channel) with boring_filesys
requires  [
  lemma Reachability1 :
    exists-trace "Ex x #j  . Computed(x) @ #j" ;
  lemma Reachability2 :
    exists-trace "Ex #j  . Computed(add(add(ichi, ichi), add(ichi,ichi))) @ #j" 
    ]