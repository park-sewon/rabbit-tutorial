(* Very Simple RAB file for computing 4 *)

load "theory.rab"


(***********)
(* declare system calls *)
(* [A] -> [B] waits for A instead of abort 
 * [A] -> [B] => [C] -> [D] runs [A] -> [B] then  [C] -> [D]
 * preconditions are consumed; e.g., [A] -> [] when succeeds remove [A]
 * All facts, unless scoped by a channel variable, are local to the 
   process that calls the system call. *)

(* Fr is reserved *)
syscall send_udp(channel c, v) : [] -> [c:store(v)]
syscall mytest(path p) : [] -> [test(p)]
syscall recv_udp(channel c) return v : [c:store(v)] -> [] 

syscall set_pid() : [&Fr(x)] -> [pid(x)]


attack tampar (channel c) : [c:store(v), &In(w)] -> [c:store(w), test(c)]
attack eaves  (process p) : [ p%frame(v)] -> [Out(v), p%frame(v)]



syscall connect_tcp(channel c)
  : [] -> [ask(c)] => [accept(c)] -> [connect(c)]
syscall accept_tcp(channel c)
  : [ask(c)] -> [accept(c)] => [connect(c)] -> [connect(c)]
syscall send_tcp(channel c, v)
  : [connect(c)] -> [connect(c), dataa(c, v)] => [receipt(c)] -> []
syscall recv_tcp(channel c) return v
  : [connect(c), dataa(c, v)] -> [connect(c), receipt(c)] 

(* filesys *)

syscall ropen (path p, v) return x : [&Fr(x)] -> [p.fd(x)]  
syscall read (path p) return x : [p.File(x)] -> [p.File(x)] 

(***********)
(** declare types with their classes *)
type filesys_t 	: filesys
type server_t 	: process
type client_t 	: process
type channel_t 	: channel


(***********)
(** declare allowed accesses and attacks. 
    Attacks under the current extension is not supported yet.. *)
allow client_t channel_t [send_udp, recv_udp]
allow server_t channel_t [send_udp, recv_udp]
allow client_t filesys_t [ropen] 

allow attack channel_t [tampar]



(***********)
(** define channels and file systems *)
channel decent_channel : channel_t
filesys boring_filesys = [{path: "some/path", data: O, type: filesys_t}]


(***********)
(** define process templates *)
process client(c) with client_t {
	let mytwo = add(ichi, ichi) ; 
	let rabbit = ichi;
	main {
		for i in range(3, 5)
		{
			skip;
		}

		let _ = send_udp(c, mytwo) @ Querying();
		let four = recv_udp(c) @ Computed(four);
	}
}

process server(c) with server_t {
	function double (x1, x2){
		let y = add (x1, x1) @ Doubling(x1);
		return y;
	}
	main {
		skip;
		let x = recv_udp(c) @ Receiving(x); 
		if (x = add(ichi, ichi))
		{
		let y = x; 
		let z = x;
		let double_x = double(x, x); 
		let _ = send_udp(c, double_x);
		}
		else 
		{
		skip;
		}
		skip;
	}
}


(***********)
(** realize a system *)
system client(decent_channel) with boring_filesys
||     server(decent_channel) with boring_filesys
requires  [
  lemma Reachability1 :
    exists-trace "Ex x #j  . Computed(x) @ #j" ;
  lemma Reachability2 :
    exists-trace "Ex #j  . Computed(add(add(ichi, ichi), add(ichi,ichi))) @ #j" 
    ]