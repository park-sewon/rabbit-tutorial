(* security primitives *)
function pk:1
function enc:2
function sign:2
function dec:2
function fst:1
function snd:1
equation fst ((x, y)) = x
equation snd ((x, y)) = y
function true:0
function verify:3
equation dec(enc(x, y), y) = x
equation verify (sign(d, k), d, pk(k)) = true

(* load syscalls on channels *)
load "udp_rpc.rab"

(* picture *)
syscall get_picture () {
  case [::Fr(v)] → return v end
}

(* filesys *)
function h:1

syscall fopen (p) {
	put[p.open()]; 
	return h(p)
}

syscall fread (y){
  case
  | [y = h(p)] →
    case 
    | [p.File(x), p.open()] →
      put[p.File(x), p.open()];
      return x
    end
  end
}

syscall fclose (y) {
  case [y = h(p)] →
    case [p.open()] → 
      skip
    end
  end
}

(***********)
(** declare types with their classes *)
type readonly_t   : filesys

type server_t 	  : process
type client_t 	  : process
type client_ta_t  : process

type udp_t 	  : channel
type rpc_t 	  : channel

(***********)
(** access control *)
allow client_t udp_t [send]
allow server_t udp_t [recv]

allow client_t rpc_t [connect_rpc, invoke_rpc, close_rpc]
allow client_ta_t rpc_t [accept_rpc]
allow client_ta_t rpc_t [.]

allow client_t [get_picture]

allow client_ta_t readonly_t  [fopen, fread, fclose] 
allow server_t readonly_t     [fopen, fread, fclose]  


(***********)
(** attacker model *)

(*
attack tampar_ch (c) {
  case [c::store(j), In(w)] ->
    put [c::store(w)]
  end
}
*)

passive attack eaves_mem (v) {
	put [::Out(v)]
}

(** allow attack udp_t [tampar_ch] *)
allow client_t [eaves_mem]


(***********)
(** global constants *)
const fresh priv_k
const fresh sym_k
const fresh init_data


(***********)
(** installed channels and filesystems *)
channel udp : udp_t

channel rpc : rpc_t

filesys client_fs = 
  [ 
    {path: "/secret/pub", data: pk(priv_k), type: readonly_t}
  ]

filesys server_fs = 
  [ 
    {path: "/secret/pub", data: pk(priv_k), type: readonly_t}
  ]

filesys client_ta_fs = 
  [ 
    {path: "/secret/priv", data: enc(priv_k, sym_k), type: readonly_t}
  ]

(***********)
(** process templates *)
process client(ch_net : udp_t, ch_rpc : rpc_t) : client_t 
{  
	let dev_path = "/dev/camera"
	let privkey_path = "/secret/priv"
	let invoke_func = "sign_image"

	main 
  	{

		let conn = connect_rpc(ch_rpc) in 
		
		let image = get_picture() in 

		let sig = invoke_rpc(conn, invoke_func, image, privkey_path) in

		_ := eaves_mem((sig, image));

		_ := send(ch_net, (sig, image)); 

		event [::ImgSend(image)];
		    	
	  	_ := close_rpc(conn) ;

	  	event [::ClientClose ()]
  	
  	}
}

process client_ta(ch_rpc : rpc_t) : client_ta_t 
{
	let fek = sym_k

	function sign_image(image, privkey_path) 
	{
    (* 
    let privkey_fd = fopen(privkey_path) in
    
    let privkey = fread(privkey_fd) in
    
    let privkey0 = dec(privkey, fek) in 
    
    let sig = sign(image, privkey0) in
    
    _ := fclose(privkey_fd);

    return sig *)

    let sig = sign(image, dec(enc(priv_k, sym_k), fek)) in
    	return sig

	}
  
	main 
	{
		_ := accept_rpc(ch_rpc);
		repeat
			[ch_rpc::invoke(fname, image, priv_path)] ->
				case
					[fname = "sign_image"] ->
						let signed = sign_image(image, priv_path) in
							put[ch_rpc::returned(signed)]		
				
					| [fname <> "sign_image"] ->
						event [InValidName(fname)]
				end 
		until
			[ch_rpc::exit()] -> skip 
		end;
		event [::ClientTAClose ()]

	}
}

process server(ch_net : udp_t) : server_t 
{
	let pubkey_path = "/secret/pub"
  
	main 
	{
	    let pubkey_fd = fopen(pubkey_path) in 
	    event [::A()];
	    let pubkey = fread(pubkey_fd) in 
	    event [::B()];
	    repeat 
		| [] -> 
	    	let p = recv(ch_net) in
			let res = verify(fst(p), snd(p), pubkey) in 
			case 
				[res =  true] ->
					event [::ImgRecvValid(snd(p))]
					
				| [res <> true] -> 
					event [::ImgRecvInvalid(snd(p))]
			end
					
		until
			[::False()] -> skip 
		end 	    
  	}
}


(***********)
system 
	client(udp, rpc) with client_fs
||	server(udp) with server_fs 
||	client_ta(rpc) with client_ta_fs
requires  [
  lemma Reachable1 :
    exists-trace "Ex #j  . A() @ #j" ;
  lemma Reachable2 :
    exists-trace "Ex #j  . B() @ #j" ;
  lemma Reachable3 :
    exists-trace "Ex #j  . AAA() @ #j" ;
  lemma Reachable4 :
    exists-trace "Ex #j  . BBB() @ #j" ;
  lemma Reachable5 :
    exists-trace "Ex x #j  . Took(x) @ #j" ;
  lemma Reachable :
    exists-trace "Ex x #i #j  . ClientClose() @ #j & ImgRecvValid(x) @ #i" ;

  lemma Correspondence :
    all-traces "All x #j  . ImgRecvValid(x) @ #j ==> Ex #i . ImgSend (x) @ i & i < j" 
  ]

