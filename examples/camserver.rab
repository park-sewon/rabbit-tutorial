(* security primitives *)
function pk:1
function enc:2
function sign:2
function dec:2
function fst:1
function snd:1
equation fst ((x, y)) = x
equation snd ((x, y)) = y
function true:0
function verify:3
equation dec(enc(x, y), y) = x
equation verify (sign(d, k), d, pk(k)) = true

(* load syscalls on channels *)
load "udp_rpc.rab"

(* picture *)
syscall get_picture () return v : [&Fr(v)] -> [] 

(* filesys *)
function h:1

syscall fopen (path p) return h(p) 
  : [] -> [p.open()]  

syscall fread (y) return x {y = h(p)}
  : [p.File(x), p.open()] -> [p.File(x), p.open()] 

syscall fclose (y) {y = h(p)}
  : [p.open()] -> [] 

(***********)
(** declare types with their classes *)
type readonly_t   : filesys

type server_t 	  : process
type client_t 	  : process
type client_ta_t  : process

type udp_t 	  : channel
type rpc_t 	  : channel

(***********)
(** access control *)
allow client_t udp_t [send]
allow server_t udp_t [recv]

allow client_t rpc_t [connect_rpc, invoke_rpc, close_rpc]
allow client_ta_t rpc_t  [accept_rpc, run_rpc]

allow client_t [get_picture]

allow client_ta_t readonly_t  [fopen, fread, fclose] 
allow server_t readonly_t     [fopen, fread, fclose]  


(***********)
(** attacker model *)

attack tampar_ch (channel c) : [c:store(v), In(w)] -> [c:store(w)]
passive attack eaves_mem (v) : [] -> [&Out(v)]

allow attack udp_t [tampar_ch]
allow client_t [eaves_mem]


(***********)
(** global constants *)
const fresh priv_k
const fresh sym_k
const fresh init_data


(***********)
(** installed channels and filesystems *)
channel udp : udp_t

channel rpc : rpc_t

filesys client_fs = 
  [ 
    {path: "/secret/pub", data: pk(priv_k), type: readonly_t}
  ]

filesys server_fs = 
  [ 
    {path: "/secret/pub", data: pk(priv_k), type: readonly_t}
  ]

filesys client_ta_fs = 
  [ 
    {path: "/secret/priv", data: enc(priv_k, sym_k), type: readonly_t}
  ]

(***********)
(** process templates *)
process client(ch_net, ch_rpc) with client_t 
{  
	let dev_path = "/dev/camera";
	let privkey_path = "/secret/priv";
	let invoke_func = "sign_image";

	main 
  	{
		
		let conn = connect_rpc(ch_rpc) @ A();
		
		for i in range(1, 3)
		{
			let image = get_picture() @ B();
	      	
			let sig = invoke_rpc(ch_rpc, invoke_func, (image, privkey_path)); 

			eaves_mem((sig, image));

			let _ = send(ch_net, (sig, image)) @ ImgSend(image);
	    	
		} 

    	let _ = close_rpc(conn) ;
    	skip @ ClientClose ();
  	}
}

process client_ta(ch_rpc) with client_ta_t 
{
	let fek = sym_k;

  	function sign_image(image, privkey_path) 
  	{
	    
	    (* let privkey_fd = fopen(privkey_path);
	    
	    let privkey = fread(privkey_fd);
	    
	    let privkey0 = dec(privkey, fek);  
	    
	    let sig = sign(image, privkey0);
	    

	    let _ = fclose(privkey_fd); *)
	 
	    let sig = sign(image, dec(enc(priv_k, sym_k), fek));


	    return sig;
	}
  
  	main 
  	{
    	let _ = accept_rpc(ch_rpc); 
    	let _ = run_rpc(ch_rpc);
    	let _ = run_rpc(ch_rpc);
    	skip @ ClientTAClose ();
    	
  	}
}

process server(ch_net) with server_t 
{
	let pubkey_path = "/secret/pub";
  
	main 
	{
	    let pubkey_fd = fopen(pubkey_path);
	    let pubkey = fread(pubkey_fd);
		for i in range (1, 3)
		{
			let p = recv(ch_net);
			let res = verify(fst(p), snd(p), pubkey);
			if (res = true) 
			{
        		skip @ ImgRecvValid(snd(p));
      		} 
      		else 
      		{
        		skip @ ImgRecvInvalid(snd(p));
      		}
    	}
    	let _ = fclose(pubkey_fd);
    	skip @ ServerClose ();
  	}
}


(***********)
system 
	client(udp, rpc) with client_fs
||	server(udp) with server_fs
||	client_ta(rpc) with client_ta_fs
requires  [
  lemma Reachability1 :
    exists-trace "Ex #i #j #k  . ClientClose() @ i &  ClientTAClose () @ j & ServerClose () @ k " ;
  lemma Correspondence :
    all-traces "All x #j  . ImgRecvValid(x) @ #j ==> Ex #i . ImgSend (x) @ i & i < j" 
    ]


    