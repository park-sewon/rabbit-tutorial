(* security primitives *)
function pk:1
function enc:2
function sign:2
function dec:2

function verify:3

function fst:1
function snd:1
function test:0
function true:0

equation fst ((x, y)) = x
equation snd ((x, y)) = y
equation dec(enc(x, y), y) = x
equation verify (sign(d, k), d, pk(k)) = true

(* syscall on channels *)

(** asynchronous channels *)
syscall send(channel c, v) 
  : [] -> [c:store(v)]
syscall recv(channel c) return v 
  : [c:store(v)] -> [] 

(** synchronous rpc channel *)

syscall connect_rpc (channel c) return x
  : [] -> [c:ask()] 
 => [c:accept(), &Fr(x)] -> [c:connect(), chid(c, x)]

syscall invoke_rpc (channel c, f, args) return x
  	: [c:connect()] -> [c:invoke(f, args), c:connect()]
	=>[c:hearback(x)] -> []

syscall close_rpc (i)
	: [c:connect(), chid(c, i)] -> [c:close()]

syscall accept_rpc (channel c)
	: [c:ask()] -> [c:accept()] 
	=>
	{!{[c:invoke(f, args)] -> [run(f, args)] => [returned(f, x)] -> [c:hearback(x)]}
	||  [c:close()] -> []}


	(* => ! ([c:invoke(f, args)] -> [connect(c)] || [c:close()] -> []) *)

(* picture *)
syscall get_picture () return v : [&Fr(v)] -> [] 


(* filesys *)
syscall fopen (path p) return x 
  : [&Fr(x)] -> [p.fd(x)]  

syscall fread (y) return x 
  : [p.File(x), p.fd(y)] -> [p.File(x), p.fd(y)] 

syscall fclose (y)
  : [p.File(x), p.fd(y)] -> [p.File(x)] 


(* attacker model *)
attack tampar_ch (channel c) : [c:store(v), In(w)] -> [c:store(w)]
attack eaves_ch  (channel c) : [c:store(v)]  	   -> [c:store(v), Out(v)]
attack drop_ch   (channel c) : [c:store(v)] 	   -> []


(***********)
(** declare types with their classes *)
type read_only 	  : filesys

type server_t 	  : process
type client_t 	  : process
type client_ta_t  : process

type sync_t 	  : channel
type async_t 	  : channel

(***********)
allow client_t async_t [send]
allow client_t sync_t 	   [connect_rpc, invoke_rpc, close_rpc]
allow client_t [get_picture]

allow client_ta_t sync_t  [accept_rpc]
allow client_ta_t read_only [fopen, fread, fclose]  

allow server_t async_t [recv]
allow server_t read_only [fopen, fread, fclose]  




(***********)
(*
allow attack sync_t [tampar]
allow attack async_t [tampar]
*)

(***********)
const fresh priv_k
const fresh sym_k
const fresh init_data


(***********)
channel udp : async_t
channel rpc : sync_t

(***********)
filesys client_fs = 
  [ 
    {path: "/secret/pub", data: pk(priv_k), type: read_only}
  ]

filesys server_fs = 
  [ 
    {path: "/secret/pub", data: pk(priv_k), type: read_only}
  ]

filesys client_ta_fs = 
  [ 
    {path: "/secret/priv", data: enc(priv_k, sym_k), type: read_only}
  ]

(***********)
process client(ch_net, ch_rpc) with client_t 
{  
	let dev_path = "/dev/camera";
	let privkey_path = "/secret/priv";
	let invoke_func = "sign_image";

	main 
  	{
		
		let conn = connect_rpc(ch_rpc);
		
		for i in range(1, 3)
		{
			let image = get_picture() @ C();
	      	
	      	let sig = invoke_rpc(ch_rpc, invoke_func, (image, privkey_path)); 
	      	skip @Got(sig);
	      	
	      	let _ = send(ch_net, (sig, image)) @ ImgSend(image);
	    	
		} 

    	let _ = close_rpc(conn) @ ClientClose ();
  	}
}

process client_ta(ch_rpc) with client_ta_t 
{
	let fek = sym_k;

  	function sign_image(image, privkey_path) 
  	{
	    
	    let privkey_fd = fopen(privkey_path);
	    
	    let privkey = fread(privkey_fd);
	    
	    let privkey0 = dec(privkey, fek);
	    
	    let sig = sign(image, privkey0);
	    
	    let _ = fclose(privkey_fd);
	 
	    return sig;
	}
  
  	main 
  	{
    	let conn = accept_rpc(ch_rpc); 
    	skip @ ClientTAClose ();
  	}
}

process server(ch_net) with server_t 
{
	let pubkey_path = "/secret/pub";
  
	main 
	{
	    let pubkey_fd = fopen(pubkey_path);
	    let pubkey = fread(pubkey_fd);
		for i in range (1, 3)
		{
			let p = recv(ch_net);
			let res = verify(fst(p), snd(p), pubkey);
			if (res = true) 
			{
        		skip @ ImgRecvValid(snd(p));
      		} 
      		else 
      		{
        		skip @ ImgRecvInvalid(snd(p));
      		}
    	}
    	let _ = fclose(pubkey_fd);
    	skip @ ServerClose ();
  	}
}


(***********)
system 
	client(udp, rpc) with client_fs
||	server(udp) with server_fs
||	client_ta(rpc) with client_ta_fs
requires  [
  lemma Reachability1 :
    exists-trace "Ex #i #j #k  . ClientClose() @ i &  ClientTAClose () @ j & ServerClose () @ k " ;
  lemma Correspondence :
    all-traces "All x #j  . ImgRecvValid(x) @ #j ==> Ex #i . ImgSend (x) @ i & i < j" 
    ]


    