external function plus:2
external function minus:1
external function zero:0
external constant one
equation plus(one, zero) = one
equation plus(x, zero) = x

(* define external function as 
	external function fname:arity *)

external function fd:1

(*  Predefined facts for external functions: 
		- File(x, d): path x stores data d 
		- Store(x, d): variable x stores data d *)

(* some external instruction better suits prelude: prelude.rabbit *)
(* 
external instruction open(x) : [File(x, d), Fr(y)] => [return y : Fd(x, y), File(x, d)] 
external instruction read(x) : [Fd(y, x), File(y, d)] =>  [return d : Fd(y, x), File(y, d)]
external instruction write(x, d) : [Fd(y, x), File(y, _)] => [Fd(y, x), File(y, d)]
external instruction close(x) : [Fd(y, x), File(y, d)] => [File(y, d)] 
*)

(* example external instructions: *)
(* 
external instruction take_picture(y) : [Fd(y, z), File(z, _)] => [Fd(y, z), File(z, (fresh d))]
external instruction read_picture(y) : [Fd(y, z), File(z, _)] => [return fresh n : ]
external instruction make_nonce() : [] => [return fresh n : ]
*)

type mytype: filesys
type mytype2: process
type mytype6: process
type mytype7: channel

init_const sewon = zero;

channel mychan = {
	transfer: stream, type: mytype7
}

allow mytype2 mytype7 [send, recv]

filesys test = [
	{path: haha, data: zero, type: mytype},
	{path: haha, data: zero, type: mytype}
	]

process testtest(a, b, c) with mytype2 {
	let e = one ; 
	let d = a;

	function test2 (s, j){
		skip @ Test(d);	
		let k = d; 
		let y = send(a, d);
		return j;
	}

	function test3 (jjj, jjjj){
		let x = test2(jjj, jjj) @ Test(jjj);
		return x ; 
	}

	main {
	skip;
	}

}

system testtest(mychan,mychan,mychan) with test requires [lemma a : True]