(* Very Simple RAB file for computing 4 *)

load "theory.rab"
load "udp.rab"

(* syscall on channels *)

(** asynchronous channels *)
syscall send_async(channel c, v) 
  : [] -> [c:store(v)]
syscall recv_async(channel c) return v 
  : [c:store(v)] -> [] 

(** asynchronous channels *)
syscall connect(channel c)
  : [] -> [ask(c)] 
 => [accept(c)] -> [connect(c)]
syscall accept(channel c)
  : [ask(c)] -> [accept(c)] 
 => [connect(c)] -> [connect(c)]
syscall send_sync(channel c, v)
  : [connect(c)] -> [connect(c), dataa(c, v)] 
 => [receipt(c)] -> []
syscall recv_sync(channel c) return v
  : [connect(c), dataa(c, v)] -> [connect(c), receipt(c)] 

(* filesys *)
syscall open (path p, v) return x 
  : [&Fr(x)] -> [p.fd(x)]  
syscall read (path p) return x 
  : [p.File(x)] -> [p.File(x)] 


(* attacker model *)
attack tampar_ch (channel c) : [c:store(v), In(w)] -> [c:store(w)]
attack eaves_ch  (channel c) : [c:store(v)]  	   -> [c:store(v), Out(v)]
attack drop_ch   (channel c) : [c:store(v)] 	   -> []


(***********)
(** declare types with their classes *)
type read_only 	  : filesys

type server_t 	  : process
type client_t 	  : process
type client_tee_t : process

type sync_t 	  : channel
type async_t 	  : channel

(***********)
allow client_t async_t [send_async]
allow server_t async_t [recv_async]

allow client_t sync_t 	   [connect, accept, recv_sync, send_sync]
allow client_tee_t sync_t  [connect, accept, recv_sync, send_sync]

allow client_t filesys_t [open, read]  


(***********)
allow attack sync_t [tampar]
allow attack async_t [tampar]



(***********)
channel udp : async_t
channel rcp : sync_t


filesys camera = 
  [ 
    {path: "some/path", data: public, type: read_only},
    {path: "some/path", data: private, type: read_only},

  ]


(***********)
(** define process templates *)
process client(c) with client_t {
	let mytwo = add(ichi, ichi) ; 
	let rabbit = ichi;
	main {
		for i in range(3, 5)
		{
			skip;
		}

		let _ = send_udp(c, mytwo) @ Querying();
		let four = recv_udp(c) @ Computed(four);
	}
}

process server(c) with server_t {
	function double (x1, x2){
		let y = add (x1, x1) @ Doubling(x1);
		return y;
	}
	main {
		skip;
		let x = recv_udp(c) @ Receiving(x); 
		if (x = add(ichi, ichi))
		{
		let y = x; 
		let z = x;
		let double_x = double(x, x); 
		let _ = send_udp(c, double_x);
		}
		else 
		{
		skip;
		}
		skip;
	}
}


(***********)
(** realize a system *)
system client(decent_channel) with boring_filesys
||     server(decent_channel) with boring_filesys
requires  [
  lemma Reachability1 :
    exists-trace "Ex x #j  . Computed(x) @ #j" ;
  lemma Reachability2 :
    exists-trace "Ex #j  . Computed(add(add(ichi, ichi), add(ichi,ichi))) @ #j" 
    ]