function pk:1
function enc:2
function sign:2
function dec:2

init_const k_mac_init = fresh();
init_const k_enc_init = fresh();



process SE(i2c_ch') with secure_t {
	let k_mac = k_mac_init ;
	let k_enc = k_enc_init ;

	let chipID = fresh() ; 
	
	main (){

		(* Binding process *)

		let r = recv(i2c_ch');
		if fst r = "InitializeUpdate" 
		then 
			let cha_h = snd r; 
			let cha_c = fresh (); 
			let s_enc = h((k_enc, cha_h, cha_c));
			let s_mac = h((k_mac, cha_h, cha_c)); 
			let cry_c = cryptogram(s_mac, "card", (chah, cha_c));
			let _ = send(i2c_ch', ("InitializeUpdate_R", cha_c, cry_c));

			let r' = recv(i2c_ch');
			if fst r' = "ExternalAuthenticate" 
			then 
				let cry_h = snd r'; 
				let cry_ch = cryptogram(s_mac, "host", (cha_h, cha_c));
				if cry_c = cry_hc 
				then 
					skip @ AuthSE();
				else
					abort; (* cryptogram doesn't match *)
			else
				abort; (* the message isn't tagged with "ExternalAuthenticate" *)
		else
			abort; (* the message isn't tagged with "InitializeUpdate" *)


		(* SSK derivation rewriting rules *)

		let r = recv(i2c_ch');
		let m' = sdec(unmac(r, s_mac), s_enc);
		if m' = ("ReadObject_R", "UNIQUE_ID")
		then 
			let _ = send(i2c_ch', mac(senc((m', chipID), s_enc), s_mac));

	}	
}

(* monitor is rpc? *)
process TEE(i2c_ch', monitor') with secure_t{
	let k_mac = k_mac_init ;
	let k_enc = k_enc_init ;
	let huc = fresh();

	let s_enc ; 
	let s_mac ; 
	
	let ssk;

	main(){

		(* Binding process *)

		let cha_h = fresh (); 
		let _ = send(ic2_ch', ("InitializeUpdate", cha_h)); 
		let r = recv(ic2_ch');
		if fst r = "InitializeUpdate_R" 
		then 
			let cha_c = fst (snd r); 
			let cry_c = snd (snd r); 

			let s_enc = h((k_enc, cha_h, cha_c)); 
			let s_mac = h((k_mac, cha_h, cha_c));
			let cry_hc = cryptogram(s_mac, "card", (cha_h, cha_c)); 

			if cry_c = cry_hc 
			then  
				let cry_h  = cryptogram(s_mac, "host", (cha_h, cha_c));
				let _ = send(i2c_ch', ("ExternalAuthenticate", cry_h)) @ AuthTEE();
			else 
				abort; (* cryptogram doesn't match *)
		else 
			abort; (* the message isn't tagged with "InitializeUpdate_R" *)

	
		(* SSK derivation rewriting rules *)
		
		let m = mac(senc(("ReadObject", "UNIQUE_ID"), s_enc), s_mac); 
		let _ = send (i2c_ch', m);
		let r = recv (ic2_ch'); 
		let m' = sdec(unmac(r, s_mac), s_enc);
		if fst m' = ("ReadObject_R", "UNIQUE_ID") 
		then 
			ssk := h((huk, snd m')) @ DeriveSSK(ssk);
		else 
			abort; (* the message isn't tagged with  ("ReadObject_R", "UNIQUE_ID") *)
	}

}

process REE(monitor') with secure_t {
	
	main(){

		(* TA execution rewriting rules *)

		let _ = send(monitor', "InitializeContext");
		


	}	


}



SE(i2c, k_enc, k_mac)
| REE(i2c, monitor, k_enc, k_mac, ta_uuid, command_id, payload)
| TEE(monitor, ta_sign_k)
